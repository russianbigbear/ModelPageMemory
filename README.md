## Модель страничной памяти.
Для её реализации были написаны два класса: класс **"Процесс"** и класс **"Модель виртуальной страничной памяти"**. <br/>
<br/>
Класс "Процесс", представляет из себя элемент, который включает 4 поля: 
* *_pid* - идентификатор процесса;
* *_size* - размер, занимаемый процессом, в битах;
* *_pages* - размер процесса в страницах (одна страница 4 бита);
* *_name* - имя процесса.

Так же в него входят методы по его инициализации, и методы по выводу полей. Данные методы понадобятся для методов второго класса.<br/>
<br/>
Класс "Модель виртуальной страничной памяти" – это основной класс, который и представляет из себя данную модель, как видно из названия.
Он включает несколько сложных полей:
* *_count_process* - количество процессов;
* *_amount_free_memory* - количество свободной RAM;
* *_count_pages* - количество занятых страниц процессом в RAM;
* *_list_processes* - таблица процессов;
* *_table_pages* - таблица страниц процесса;
* *_table_times* - таблица, содержащая pid процесса, количество его страниц и время добавления их в RAM;
* *_random_access_memory* - вектор, представляющий RAM;
* *_hard_disk_drive* - вектор, представляющий HDD;
* *_chain* - цепочка элементов по времени.

В программе есть глобальная переменная HDD, где HDD равен 512 бит – это размер жесткого диска.<br/>
<br/>
**_list_processes** – это простенькая таблица, элементами которой являются ранее описанный класс “Процесс”. 
Данная таблица связанна с двумя практические аналогичными таблицами, объясню их по порядку.<br/>
<br/>
**_table_pages** – это таблица, представленная в виде двумерного вектора, строками, которой являются процессы,
а ячейками страницы процесса, которые содержат “указатель” на их место в RAM.<br/>
<br/>
**_table_times** – это таблица, представленная в виде двумерного вектора, строками, которой являются процессы,
а ячейками страницы процесса, которые содержат pid процесса, номер страницы и время создания (далее В.С.)  этой страницы.<br/>
<br/>
Также можно отдельно выделить две похожих “таблицы”, 
которые представляют RAM, размером 64 бит, и HDD, размером 512 бит. Они представлены в виде вектора(массива). Они содержат PID процесса.

### Алгоритм модели
#### Замещение страниц
Алгоритм нечастого востребования (Not Frequently Used (NFU)). 
Для его реализации требуется программный счетчик с начальным нулевым значением, связанный с каждой̆ страницей̆. 
При каждом прерывании от таймера операционная система сканирует все находящиеся в памяти страницы. 
Для каждой̆ страницы к счетчику добавляется значение бита R, равное 0 или 1. 
Счетчики позволяют приблизительно отследить частоту обращений к каждой̆ странице.
При возникновении ошибки отсутствия страницы для замещения выбирается та страница, чей̆ счетчик имеет наименьшее значение.
Основной недостаток — отсутствие механизма «забывания».
Существует модификация алгоритм «старения»— перед добавлением бита R осуществляется сдвиг вправо на 1 разряд и бит R добавляется не справа, а слева.<br/>
<br/>
В программе данный алгоритм модифицирован, для его использования.
Каждой странице при создании и во время вызова присваивается время вызова/добавления. 
Если нам нужно будет освободить RAM, мы находим страницу с со старым временем и выгружаем её на HDD, освобождая место для страницы нового процесса.

#### Алгоритм добавления процесса
Метод **push_process**.<br/>
В данный метод мы отправляем добавляемый процесс. Знаем его размер в битах и страницах. Это нам понадобится в алгоритме.
1. Мы записываем процесс в RAM постранично, если есть место.
2. После делаем запись данных в _table_pages и _table_times.
3. Если места нет, то используем алгоритм замещения, то есть выгружаем старую страницу на HDD,
а нашу пишем на место старой. После делаем запись данных в _table_pages и _table_times.
Если процесс не полностью записан, то повторяем данный пункт.
4. Выводим RAM.

#### Алгоритм удаления процесса
Метод **pop_process**.<br/>
В данный метод мы отправляем PID удаляемого процесса.
1. Ищем процесс по PID, если не найден, то выводим сообщение и выходим из алгоритма, иначе переходим к следующему пункту.
2. Процесс найден, значит удаляем (зануляем) его в RAM и HDD. Так же удаляем данные о процессе из _list_process, _table_pages и _table_times.
3. Выводим RAM.

#### Алгоритм вызова страницы
Метод **call_page**, отвечает за данный алгоритм.<br/>
В него мы подаем данные: pid процесса и номер его страницы.
1. Проверяем наличие процесса и наличие страницы. При их отсутствии выводим сообщения. Если всё хорошо, то переходим к пункту 2.
2. Если страница в RAM, то обновляем её время вызова/добавления в _table_times. Выходим из метода.
3. Если страница на HDD и в RAM есть место, то пишем её в RAM, удаляя с HDD (зануляя). Обновляем время вызова страницы и выходим из метода.
4. Если страница на HDD и места в RAM нет, то используем алгоритм замещения, то есть находим старую страницу и заносим её на HDD, и на её место пишем вызванную. 
Так же обновляем время её вызова и выходим из метода.





